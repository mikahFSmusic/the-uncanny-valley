{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\n\nvar _jsxFileName = \"/Users/mfs/Desktop/web_apps/the-uncanny-valley/front/src/components/ImageMesh.tsx\",\n    _s = $RefreshSig$();\n\nimport React, { useEffect, useRef, useState } from \"react\";\nimport { Canvas, useFrame } from \"react-three-fiber\";\nimport Box from \"./Box\";\n\nconst norm = (val, minVal, maxVal, newMin, newMax) => {\n  return newMin + (val - minVal) * (newMax - newMin) / (maxVal - minVal);\n};\n\nexport const ImageMesh = props => {\n  _s();\n\n  const mesh = useRef();\n  const [boxes, addBox] = useState([]);\n  useEffect(() => {\n    if (props.imageData) {\n      const imgWidth = props.imageData.width;\n      const imgHeight = props.imageData.height;\n      const imgAspectRatio = imgWidth / imgHeight;\n      const scrWidth = window.innerWidth;\n      const scrHeight = window.innerHeight;\n      const scrAspectRatio = scrWidth / scrHeight;\n      const widthMod = 3 * imgAspectRatio / scrAspectRatio;\n      const xPadding = (2 - widthMod) / 2;\n      const xInc = widthMod / imgWidth;\n      const yInc = 2 / imgHeight;\n      const xStart = -1.0 + xPadding;\n      const yStart = 1.0;\n      let col = 0;\n      let row = 0;\n\n      for (let i = 0; i < props.imageData.data.length; i += 4) {\n        // create a point object with color data[i + 0], data[i + 1], data[i + 2], data[i + 3]\n        // and location\n        let x = xStart + col * xInc;\n        let y = yStart - row * yInc;\n        let z = norm(props.imageData.data[i + 3], 0, 255, -1, 1);\n\n        let thisBox = /*#__PURE__*/_jsxDEV(Box, {\n          position: [x, y, z]\n        }, i, false, {\n          fileName: _jsxFileName,\n          lineNumber: 49,\n          columnNumber: 23\n        }, this);\n\n        addBox([...boxes, thisBox]);\n      }\n    }\n  }, [props.imageData, boxes]);\n  console.log(boxes); // animation stage\n\n  useFrame(() => {\n    if (mesh.current) {}\n  });\n  return /*#__PURE__*/_jsxDEV(Canvas, {\n    style: {\n      minHeight: \"90vh\"\n    },\n    children: [/*#__PURE__*/_jsxDEV(\"ambientLight\", {}, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 64,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"pointLight\", {\n      position: [10, 10, 10]\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 65,\n      columnNumber: 7\n    }, this), boxes]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 63,\n    columnNumber: 5\n  }, this);\n};\n\n_s(ImageMesh, \"6G2N789I5ta0DaPFb/36/bN6t3w=\", false, function () {\n  return [useFrame];\n});\n\n_c = ImageMesh;\n\nvar _c;\n\n$RefreshReg$(_c, \"ImageMesh\");","map":{"version":3,"sources":["/Users/mfs/Desktop/web_apps/the-uncanny-valley/front/src/components/ImageMesh.tsx"],"names":["React","useEffect","useRef","useState","Canvas","useFrame","Box","norm","val","minVal","maxVal","newMin","newMax","ImageMesh","props","mesh","boxes","addBox","imageData","imgWidth","width","imgHeight","height","imgAspectRatio","scrWidth","window","innerWidth","scrHeight","innerHeight","scrAspectRatio","widthMod","xPadding","xInc","yInc","xStart","yStart","col","row","i","data","length","x","y","z","thisBox","console","log","current","minHeight"],"mappings":"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","sourcesContent":["import React, { useEffect, useRef, useState } from \"react\";\nimport { Canvas, MeshProps, useFrame } from \"react-three-fiber\";\nimport { Mesh } from \"three\";\nimport Box from \"./Box\";\n\nconst norm = (\n  val: number,\n  minVal: number,\n  maxVal: number,\n  newMin: number,\n  newMax: number\n) => {\n  return newMin + ((val - minVal) * (newMax - newMin)) / (maxVal - minVal);\n};\n\ntype ImageMeshProps = {\n  meshProps?: MeshProps;\n  imageData?: ImageData;\n};\n\nexport const ImageMesh = (props: ImageMeshProps) => {\n  const mesh = useRef<Mesh>();\n  const [boxes, addBox] = useState<Array<JSX.Element>>([]);\n  useEffect(() => {\n    if (props.imageData) {\n      const imgWidth = props.imageData.width;\n      const imgHeight = props.imageData.height;\n      const imgAspectRatio = imgWidth / imgHeight;\n\n      const scrWidth = window.innerWidth;\n      const scrHeight = window.innerHeight;\n      const scrAspectRatio = scrWidth / scrHeight;\n\n      const widthMod = (3 * imgAspectRatio) / scrAspectRatio;\n      const xPadding = (2 - widthMod) / 2;\n      const xInc = widthMod / imgWidth;\n      const yInc = 2 / imgHeight;\n      const xStart = -1.0 + xPadding;\n      const yStart = 1.0;\n      let col = 0;\n      let row = 0;\n      for (let i = 0; i < props.imageData.data.length; i += 4) {\n        // create a point object with color data[i + 0], data[i + 1], data[i + 2], data[i + 3]\n        // and location\n\n        let x = xStart + col * xInc;\n        let y = yStart - row * yInc;\n        let z = norm(props.imageData.data[i + 3], 0, 255, -1, 1);\n        let thisBox = <Box key={i} position={[x, y, z]}></Box>;\n        addBox([...boxes, thisBox]);\n      }\n    }\n  }, [props.imageData, boxes]);\n\n  console.log(boxes);\n  // animation stage\n  useFrame(() => {\n    if (mesh.current) {\n    }\n  });\n\n  return (\n    <Canvas style={{ minHeight: \"90vh\" }}>\n      <ambientLight />\n      <pointLight position={[10, 10, 10]} />\n      {boxes}\n    </Canvas>\n  );\n};\n"]},"metadata":{},"sourceType":"module"}